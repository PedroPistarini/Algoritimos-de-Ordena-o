#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Definição de uma estrutura chamada "array" contendo apenas um elemento inteiro chamado "chave"
typedef struct item {
    float info;
    int chave;
} array;

// Função para preencher um array com chaves aleatórias
void chaves(array *v, int n, int tipo) {

    if(tipo == 1)
    {
        for (int i = 0; i < n; i++) {
            v[i].info = rand() + 100;       // Números aleatorio float
            v[i].chave = rand();            //Chave de Ordenação
        }
    }

    if(tipo == 2)
    {
        for(int i = 0; i < n; i++)
        {
            v[0].chave = rand()%10000;
            v[i].info = rand() + 100;
            v[i].chave = v[i - 1].chave + rand() % 10000;
        }
    }
}

// Função para imprimir um array
void printarray(array *v, int n) {

    printf("\n Info     |     Chave \n\n");
    for (int i = 0; i < n; i++) {
        printf(" %.2f      %d\n", v[i].info, v[i].chave);
    }
}

// Função para medir o tempo de execução e imprimir em horas, minutos e segundos
void tempo(double tempo_exec, clock_t begin) {
    clock_t end = clock();
    tempo_exec += (double)(end - begin) / CLOCKS_PER_SEC;

    // Converte o tempo total em segundos para horas, minutos e segundos
    int horas = (int)(tempo_exec / 3600);
    int minutos = (int)((tempo_exec - horas * 3600) / 60);
    float segundos = (float)(tempo_exec - horas * 3600 - minutos * 60);

    printf("\nTempo de execucao: %02dh:%02dm:%.3fs\n", horas, minutos, segundos);
}

// Algoritmo de ordenação: Insertion Sort
void insertionsort(array *v, int n) {
    int i, j, temp;

    for (i = 1; i < n; i++) {
        for (j = i; j > 0 && v[j - 1].chave < v[j].chave; j--) {
            temp = v[j - 1].chave;
            v[j - 1].chave = v[j].chave;
            v[j].chave = temp;
        }
    }
}

// Algoritmo de ordenação: Bubble Sort
void bubblesort(array *v, int n) {
    
    int i, j, temp;

    for (i = 0; i <= n - 1; i++) {
        for (j = 1; j <= n - 1; j++) {
            if (v[j].chave > v[j - 1].chave) {
                temp = v[j - 1].chave;
                v[j - 1].chave = v[j].chave;
                v[j].chave = temp;
            }
        }
    }
}

// Algoritmo de ordenação: Shell Sort
void shellsort(array *v, int n) {
    int i, j, h;
    array aux;

    for (h = 1; h < n / 3; h = 3 * h + 1);

    while (h > 0) {
        h = (h - 1) / 3;
        for (i = h; i < n; i++) {
            aux = v[i];
            j = i;

            while (j >= h && v[j - h].chave < aux.chave) {
                v[j] = v[j - h];
                j -= h;
                if (j < h) break;
            }
            v[j] = aux;
        }
    }
}

// Algoritmo de ordenação: Merge Sort
void mergesort(array *v, int n) {
    array *c = malloc(sizeof(array) * n);
    sort(v, c, 0, n - 1);
    free(c);
}

void sort(array *v, array *c, int i, int f) {
    if (i < f) {
        int m = (i + f) / 2;
        sort(v, c, i, m);
        sort(v, c, m + 1, f);
        if (v[m].chave < v[m + 1].chave) {
            merge(v, c, i, m, f);
        }
    }
}

void merge(array *v, array *c, int i, int m, int f) {
    int z, iv = i, ic = m + 1;
    for (z = i; z <= f; z++)
        c[z].chave = v[z].chave;
    z = i;
    while (iv <= m && ic <= f) {
        if (c[iv].chave >= c[ic].chave) {
            v[z++].chave = c[iv++].chave;
        } else {
            v[z++].chave = c[ic++].chave;
        }
    }

    while (iv <= m) {
        v[z++].chave = c[iv++].chave;
    }
    while (ic <= f) {
        v[z++].chave = c[ic++].chave;
    }
}

// Algoritmo de ordenação: Quick Sort
void quicksort(array *v, int LI, int LS) {
    if (LI < LS) {
        int p;
        p = particao(v, LI, LS);
        quicksort(v, LI, p - 1);
        quicksort(v, p + 1, LS);
    }
}

int particao(array *v, int LI, int LS) {
    int aux, pivo, e = LI, d = LS;
    pivo = v[e].chave;

    while (e < d) {
        while ((v[e].chave >= pivo) && (e < LS)) {
            e++;
        }
        while ((v[d].chave > pivo) && (d > LI)) {
            d--;
        }
        if (e < d) {
            aux = v[e].chave;
            v[e].chave = v[d].chave;
            v[d].chave = aux;
        }
    }
    aux = v[LI].chave;
    v[LI].chave = v[d].chave;
    v[d].chave = aux;

    return d;
}


int main() {

    int tipo = 2;                               // Tipo de chave a ser inserida
    int n = 100;                                 // Número de elementos que deseja que o programa rode
    int seed = 22000341;                        // Selecionando a seed, para que todos os valores rodados sejam os mesmos
    array *v = malloc(sizeof(array) * n);

    srand(seed);
    printf(" Valor da seed executada eh: %d\n ", seed);

    chaves(v, n, tipo);

    double tempo_exec = 0.0;
    clock_t begin = clock();

    // Chame a função de ordenação desejada aqui (descomente a linha correspondente)
    // insertionsort(v, n);
     bubblesort(v, n);
    // shellsort(v, n);
    // mergesort(v, n);
    // quicksort(v, 0, n-1);

    printarray(v, n);
    tempo(tempo_exec, begin);

    return 0;
}
